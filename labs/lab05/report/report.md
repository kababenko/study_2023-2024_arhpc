---
## Front matter
title: "Лабораторная работа №5"
subtitle: "Архитектура компьютера и операционные системы"
author: "Бабенко Константин"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Приобретение практических навыков работы в Midnight Commander. Освоение инструкций 
языка ассемблера mov и int.

# Задание

Освоить работу в Midnight Commander. Написать и запустить несколько программ, 
позволяющих вводить и выводить информацию.

# Теоретическое введение

Midnight Commander — это программа, которая позволяет просматривать
структуру каталогов и выполнять основные операции по управлению файловой системой,
т.е. mc является файловым менеджером. Midnight Commander позволяет сделать работу с
файлами более удобной и наглядной.

Программа на языке ассемблера NASM, как правило, состоит из трёх секций: секция кода
программы (SECTION.text), секция инициированных (известных во время компиляции)
данных (SECTION.data) и секция неинициализированных данных (тех, под которые во
время компиляции только отводится память, а значение присваивается в ходе выполнения
программы) (SECTION.bss).

Для объявления инициированных данных в секции .data используются директивы DB, DW,
DD, DQ и DT, которые резервируют память и указывают, какие значения должны храниться в
этой памяти:
• DB (define byte) — 1 байт;
• DW (define word) — 2 байта (слово);
• DD (define double word) — 4 байта (двойное слово);
• DQ (define quad word) — 8 байт (учетверённое слово);
• DT (define ten bytes) — 10 байт.

Для объявления неинициированных данных в секции .bss используются директивы resb, resw, 
resd и другие, которые сообщают ассемблеру, что необходимо зарезервировать заданное 
количество ячеек памяти.

Инструкция языка ассемблера mov предназначена для дублирования данных источника в
приёмнике. В общем виде эта инструкция записывается в виде: mov dst,src; dst — приёмник, 
а src — источник.

Инструкция языка ассемблера int предназначена для вызова прерывания с указанным номером. 
В общем виде она записывается в виде int n; n — номер прерывания, принадлежащий диапазону 
0–255.

После вызова инструкции int 80h выполняется системный вызов какой-либо функции
ядра Linux. При этом происходит передача управления ядру операционной системы. Чтобы
узнать, какую именно системную функцию нужно выполнить, ядро извлекает номер системного 
вызова из регистра eax. Поэтому перед вызовом прерывания необходимо поместить в этот 
регистр нужный номер. Кроме того, многим системным функциям требуется передавать какие-либо 
параметры. По принятым в ОС Linux правилам эти параметры помещаются в порядке следования в 
остальные регистры процессора: ebx, ecx, edx. Если системная функция должна вернуть значение, 
то она помещает его в регистр eax.

Простейший диалог с пользователем требует наличия двух функций — вывода текста на экран и 
ввода текста с клавиатуры. Простейший способ вывести строку на экран — использовать системный 
вызов write. Этот системный вызов имеет номер 4, поэтому перед вызовом инструкции int 
необходимо поместить значение 4 в регистр eax. Первым аргументом write, помещаемым в регистр 
ebx, задаётся дескриптор файла. Для вывода на экран в качестве дескриптора файла нужно указать 
1 (это означает «стандартный вывод», т. е. вывод на экран). Вторым аргументом задаётся адрес 
выводимой строки (помещаем его в регистр ecx, например, инструкцией mov ecx, msg). Строка может 
иметь любую длину. Последним аргументом (т.е. в регистре edx) должна задаваться максимальная 
длина выводимой строки.
Для ввода строки с клавиатуры можно использовать аналогичный системный вызов read. Его 
аргументы –такие же, как у вызова write,только для «чтения» с клавиатуры используется файловый 
дескриптор 0 (стандартный ввод).
Системный вызов exit является обязательным в конце любой программы на языке ассемблер. Для 
обозначения конца программы перед вызовом инструкции int 80h необходимо поместить в регистр еах 
значение 1, а в регистр ebx код завершения 0.

# Выполнение лабораторной работы

1) Открываю Midnight Commander: (рис. @fig:001).
![Midnight Commander](1.jpg){#fig:001 width=70%}

2) Перехожу в каталог ~/work/arch-pc созданный при выполнении лабораторной работы №4:
![Перехожу в каталог ~/work/arch-pc](2.jpg){#fig:002 width=70%}

3) Создаю папку lab05 и перехожу в созданный каталог:
![Перехожу в папку lab05](3.jpg){#fig:003 width=70%}

4) Создаю файл lab5-1.asm:
![Создаю файл lab5-1.asm](4.jpg){#fig:004 width=70%}

5) Открываю файл lab5-1.asm для редактирования во встроенном редакторе:
![Открываю файл lab5-1.asm](5.jpg){#fig:005 width=70%}

6) Ввожу текст программы из листинга 5.1:
![Программа](6.jpg){#fig:006 width=70%}

7) Открываю файл lab5-1.asm для просмотра. Убеждаюсь, что файл содержит текст программы:
![Открываю файл для просмотра](7.jpg){#fig:007 width=70%}

8) Транслирую текст программы в объектный файл. Выполняю компоновку объектного файла:
![Трансляция и компоновка файла](8.jpg){#fig:007 width=70%}
Запускаю получившийся исполняемый файл: 
![Работа файла](9.jpg){#fig:009 width=70%}

# Подключение внешнего файла in_out.asm

9) Скачиваю файл in_out.asm со страницы курса в ТУИС:
![Скачиваю файл](10.jpg){#fig:010 width=70%}

10) Подключаемый файл должен лежать в том же каталоге, что и файл с программой, в которой 
он используется, переношу его сюда:
![Перенос файла](11.jpg){#fig:011 width=70%}

11) C помощью функциональной клавиши F6 создаю копию файла lab5-1.asm с именем lab5-2.asm:
![Копирование файла](12.jpg){#fig:012 width=70%}

12) Исправляю текст программы в файле lab5-2.asm с использование файла in_out.asm в 
соответствии с листингом 5.2:
![Копирование файла](13.jpg){#fig:013 width=70%}
Создаю исполняемый файл и проверяю его работу:
![Работа нового файла](14.jpg){#fig:014 width=70%}

13) В файле lab5-2.asm заменяю подпрограмму sprintLF на sprint:
![Замена подпрограммы](15.jpg){#fig:015 width=70%}
Создаю исполняемый файл и проверяю его работу:
![Работа измененной программы](16.jpg){#fig:016 width=70%}
Измененная программа не переводит регистр на следующую строку в отличие от первой.

# Домашняя работа

1. Вношу изменения в первую программу, так чтобы она выводила введенную строку:
![Изменяю первый файл](17.jpg){#fig:017 width=70%}

2. Получаю исполняемый файл:
![Получение файла](18.jpg){#fig:018 width=70%}
Проверяю его работу:
![Работа файла](19.jpg){#fig:019 width=70%}

3. Вношу изменения в вторую программу с использование подпрограмм из внешнего файла 
in_out.asm, так чтобы она выводила введенную строку:
![Изменяю второй файл](20.jpg){#fig:020 width=70%}

4. Создаю исполняемый файл:
![Создание файла](21.jpg){#fig:021 width=70%}
Запускаю файл:
![Работа файла](22.jpg){#fig:022 width=70%}

# Выводы

Я приобрёл практические навыки работы в Midnight Commander, освоил инструкции языка ассемблера 
mov и int.

# Список литературы{.unnumbered}

::: {#refs}